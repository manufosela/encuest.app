---
// Static page - surveyId handled in client from URL
---

<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Resultados - Encuestapp</title>
    <link rel="stylesheet" href="/css/survey.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <div class="fullscreen-container">
      <div class="survey-title">
        <h1 id="survey-name">Cargando...</h1>
      </div>
      
      <div id="results-content" class="results-content">
        <!-- Content will be populated when there's an active question -->
      </div>
    </div>

    <script type="module">
      import { 
        listenToActiveQuestion,
        listenToVotes,
        getSurvey
      } from '/lib/database.js';
      
      // Get surveyId from URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const surveyId = urlParams.get('id');
      
      let currentQuestion = null;
      let unsubscribeVotes = null;
      let currentChart = null;
      let lastVotes = null;
      
      // Load survey info
      async function loadSurveyInfo() {
        try {
          const survey = await getSurvey(surveyId);
          if (survey) {
            document.getElementById('survey-name').textContent = survey.name;
          }
        } catch (error) {
          console.error('Error loading survey:', error);
        }
      }
      
      // Listen to active question
      const unsubscribeQuestion = listenToActiveQuestion(surveyId, (question) => {
        const resultsContent = document.getElementById('results-content');
        
        if (!question) {
          // No active question - show waiting message
          resultsContent.innerHTML = `
            <div class="waiting-message">
              <div class="waiting-icon">‚è≥</div>
              <h2>En este momento no hay encuestas activas</h2>
            </div>
          `;
          
          // Clean up votes listener
          if (unsubscribeVotes) {
            unsubscribeVotes();
            unsubscribeVotes = null;
          }
          
          // Destroy chart
          if (currentChart) {
            currentChart.destroy();
            currentChart = null;
          }
          
          // Reset current question
          currentQuestion = null;
          return;
        }
        
        // New question - setup votes listener
        if (!currentQuestion || currentQuestion.id !== question.id) {
          console.log('New question received:', question);
          currentQuestion = question;
          
          // Clean up previous votes listener
          if (unsubscribeVotes) {
            unsubscribeVotes();
          }
          
          // Destroy existing chart when switching questions
          if (currentChart) {
            currentChart.destroy();
            currentChart = null;
          }
          
          // Listen to votes for this question
          unsubscribeVotes = listenToVotes(surveyId, question.id, (votes) => {
            lastVotes = votes;
            displayResults(currentQuestion, votes);
          });
        } else {
          // Same question but check if question data changed (e.g., winner field)
          const newQuestionData = JSON.stringify(question);
          if (currentQuestion && JSON.stringify(currentQuestion) !== newQuestionData) {
            console.log('Question data changed, updating display...');
            currentQuestion = question;
            // Force update with last known votes
            if (lastVotes !== null) {
              displayResults(currentQuestion, lastVotes);
            }
          }
        }
      });
      
      let currentQuestionHTML = null;
      
      function displayResults(question, votes) {
        const resultsContent = document.getElementById('results-content');
        
        // Ensure votes is an object and calculate total votes
        const voteData = votes || {};
        const totalVotes = Object.values(voteData).reduce((sum, count) => sum + count, 0);
        
        // Kahoot colors for consistency (green first, red second)
        const kahootColors = ['#26890C', '#E21B3C', '#1368CE', '#FFD602', '#FF8C00', '#9C27B0', '#00BCD4', '#FF5722'];
        
        // Check if we need to rebuild the HTML (new question)
        const questionHTML = question.text + question.votingEnabled;
        const winnerHTML = question.winner ? JSON.stringify(question.winner) : 'no-winner';
        const needsRebuild = currentQuestionHTML !== questionHTML || !document.getElementById('resultsChart');
        
        // Always show legend
        const hasLongOptions = true;
        
        if (needsRebuild) {
          console.log('Rebuilding HTML for new question or missing chart');
          console.log('Question options:', question.options);
          currentQuestionHTML = questionHTML;

          // Create results display
          resultsContent.innerHTML = `
            <div class="question-container">
              <h2 class="question-title">
                <span class="status-indicator ${question.votingEnabled ? 'active' : 'inactive'}"></span>
                ${question.text}
              </h2>

              <div class="chart-legend-horizontal">
                <div class="legend-items-horizontal">
                  ${question.options && question.options.length > 0 ? question.options.map((option, index) => `
                    <div class="legend-item-horizontal">
                      <span class="legend-color" style="background-color: ${kahootColors[index % kahootColors.length]};"></span>
                      <span class="legend-text">${option}</span>
                    </div>
                  `).join('') : ''}
                </div>
              </div>
              
              <div class="chart-container-fullscreen">
                <div class="chart-wrapper-fullscreen">
                  <canvas id="resultsChart"></canvas>
                </div>
              </div>
              
              <div class="bottom-info">
                <div class="vote-summary" id="vote-summary">
                  Total: ${totalVotes} ${totalVotes === 1 ? 'voto' : 'votos'}
                </div>
                
                <div id="winner-section">
                  ${question.winner ? `
                    <div class="winner-badge">
                      <span class="winner-icon">üèÜ</span>
                      <span class="winner-text">Ganador: ${question.options[question.winner.optionIndex]}</span>
                    </div>
                  ` : ''}
                </div>
              </div>
            </div>
          `;
          
          // Reset chart since HTML was rebuilt
          currentChart = null;
        } else {
          // Just update the vote summary
          const voteSummary = document.getElementById('vote-summary');
          if (voteSummary) {
            voteSummary.textContent = `Total: ${totalVotes} ${totalVotes === 1 ? 'voto' : 'votos'}`;
          }
        }
        
        // Always update winner section (regardless of rebuild)
        const winnerSection = document.getElementById('winner-section');
        if (winnerSection) {
          winnerSection.innerHTML = question.winner ? `
            <div class="winner-badge">
              <span class="winner-icon">üèÜ</span>
              <span class="winner-text">Ganador: ${question.options[question.winner.optionIndex]}</span>
            </div>
          ` : '';
        }
        
        // Create or update Chart.js chart
        createChart(question, voteData, kahootColors, totalVotes, hasLongOptions);
      }
      
      function createChart(question, votes, colors, totalVotes, hasLongOptions = true) {
        const ctx = document.getElementById('resultsChart');
        if (!ctx) {
          console.error('Chart canvas not found');
          return;
        }
        
        // Update chart wrapper height dynamically for fullscreen
        const wrapper = ctx.closest('.chart-wrapper-fullscreen');
        if (wrapper) {
          const rect = wrapper.getBoundingClientRect();
          ctx.style.height = rect.height + 'px';
        }
        
        // Prepare data - ensure all options have a value (0 if no votes)
        const voteData = question.options.map((_, index) => votes[index] || 0);
        const backgroundColors = question.options.map((_, index) => colors[index % colors.length]);
        
        // Use color indicators if we have long options (colored squares)
        const chartLabels = hasLongOptions ? 
          question.options.map((_, index) => `‚óè`) : 
          question.options;
        
        console.log('Chart data:', { question: question.text, voteData, totalVotes, hasLongOptions });
        
        // If chart doesn't exist, create it
        if (!currentChart) {
          currentChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: chartLabels,
              datasets: [{
                label: 'Votos',
                data: voteData,
                backgroundColor: backgroundColors,
                borderColor: backgroundColors.map(color => color + 'dd'),
                borderWidth: 3,
                borderRadius: 12,
                barPercentage: 0.6,
                maxBarThickness: 100
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              resizeDelay: 0,
              animation: {
                duration: 600,
                easing: 'easeOutQuart'
              },
              layout: {
                padding: {
                  top: 20,
                  bottom: 20,
                  left: 10,
                  right: 10
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    stepSize: 1,
                    font: {
                      size: 18,
                      weight: '600'
                    },
                    color: '#666',
                    callback: function(value) {
                      if (Math.floor(value) === value) {
                        return value;
                      }
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.08)',
                    drawBorder: false
                  }
                },
                x: {
                  ticks: {
                    font: {
                      size: 16,
                      weight: '600'
                    },
                    color: '#333',
                    maxRotation: 45,
                    minRotation: 0,
                    autoSkip: false
                  },
                  grid: {
                    display: false
                  }
                }
              },
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  backgroundColor: 'rgba(0, 0, 0, 0.85)',
                  padding: 16,
                  borderRadius: 12,
                  titleFont: {
                    size: 18,
                    weight: '600'
                  },
                  bodyFont: {
                    size: 16
                  },
                  callbacks: {
                    label: function(context) {
                      const value = context.parsed.y;
                      const percentage = totalVotes > 0 ? Math.round((value / totalVotes) * 100) : 0;
                      const optionText = hasLongOptions ? question.options[context.dataIndex] : context.label;
                      return [`${optionText}`, `${value} ${value === 1 ? 'voto' : 'votos'} (${percentage}%)`];
                    },
                    title: function(context) {
                      if (hasLongOptions) {
                        return 'Opci√≥n';
                      }
                      return context[0].label;
                    }
                  }
                }
              },
              onHover: (event, activeElements) => {
                ctx.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
              }
            }
          });
        } else {
          // Update existing chart
          console.log('Updating existing chart with data:', voteData);
          currentChart.data.labels = chartLabels;
          currentChart.data.datasets[0].data = voteData;
          currentChart.data.datasets[0].backgroundColor = backgroundColors;
          currentChart.data.datasets[0].borderColor = backgroundColors.map(color => color + 'dd');
          currentChart.update('active');
        }
      }
      
      
      // Load initial data
      loadSurveyInfo();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        unsubscribeQuestion();
        if (unsubscribeVotes) {
          unsubscribeVotes();
        }
        if (currentChart) {
          currentChart.destroy();
        }
      });
    </script>

    <style>
      .waiting-message {
        text-align: center;
        padding: 4rem 2rem;
        background: white;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        margin: 4rem auto;
        max-width: 500px;
      }

      .waiting-icon {
        font-size: 5rem;
        margin-bottom: 1.5rem;
        animation: pulse 2s infinite;
      }

      .waiting-message h2 {
        color: #333;
        margin-bottom: 1rem;
        font-size: 2rem;
        font-weight: 600;
      }

      .waiting-message p {
        color: #666;
        font-size: 1.2rem;
        line-height: 1.6;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }
    </style>
  </body>
</html>